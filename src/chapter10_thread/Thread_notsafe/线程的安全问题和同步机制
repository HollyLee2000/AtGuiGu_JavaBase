原因：线程1操作资源尚未结束的情况下，其他线程也参与进来对ticket进行操作
解决方法：保证一个线程a在操作资源的过程中，其他线程必须等待，直到线程a操作ticket结束以后其他线程才可以进来操作资源(共享数据)
使用线程同步机制：
1.同步代码块：
    synchronized(同步监视器){
        //需要被同步的代码
    }

    说明：
        》 需要被同步的代码，即为操作共享数据的代码
        》 共享数据：即多个线程都需要操作的数据
        》 需要被同步的代码，在被synchronized包裹以后，就使得一个线程在操作这些代码的过程中，其他线程必须等待
        》 同步监视器，俗称锁。哪个线程获得了锁，哪个线程就能执行需要被同步的代码。
        》 同步监视器，可以使用任何一个类的对象充当。但是多个线程必须共用一个同步监视器。

    注意：在实现runnable接口的方式中，可以考虑使用this作为同步监视器，但在继承Thread类的方式中需慎用this，可考虑使用当前类.class。

2.同步方法：
说明：
    》 如果操作共享数据的代码完整地声明在了一个方法中，那么我们就可以将此方法声明为同步方法即可。
    》 非静态的同步方法，默认同步监视器是this，静态的同步方法，默认同步监视器是当前类本身

3.Synchronized好处：解决了线程安全问题。
    弊端：在操作共享数据时，多线程其实是串行执行的，意味着性能降低。

