1.线程通信的理解：
当我们需要`多个线程`来共同完成一件任务，并且我们希望他们`有规律地执行`时，那么多线程之间需要一些通信机制，可以协调他们的工作，以此实现多线程共同操作一份数据

2.三个方法的使用：
wait():线程一旦执行此方法，就进入等待，同时释放对同步监视器的调用
notify():一旦执行此方法，就会唤醒被wait()的线程中优先级最高的那一个线程。如果被wait()的多个线程的优先级相同，那么随机唤醒一个。
        被唤醒的线程从当初被wait的位置继续执行。
notifyAll():一旦执行此方法，就会唤醒所有被wait的线程

3.注意点：
》上述三个方法的使用必须是在同步代码块或同步方法中。不能使用在Lock当中(超纲：Lock需要配合condition实现线程间的通信)
》此三个方法的调用者必须是同步代码块或同步方法的监视器，否则会报IllegalMonitorStateException异常
》此三个方法声明在Object类中(是native方法)，因为同步监视器可以是任意Object的对象，所以任意Object的对象都应能调用这些方法

》》复习：凡是在方法中没有写是谁来调用的，如果是非静态方法，则默认是this来调用的(比如this.notify())，
       如果是静态方法，则默认是当前类来调用的，调用的也只能是静态方法

4.案例：
案例1：使用两个线程打印1-100。线程1、线程2交替打印。

案例2：生产者&消费者。生产者(Productor)将产品交给店员(Clerk)，而消费者(Customer)从店员处取走产品，店员一次只能持有固定数量的产品(比如:20)，
      如果生产者试图生产更多的产品，店员会叫生产者停一下，如果店中有空位放产品了再通知生产者继续生产;如果店中没有产品了，店员会告诉消费者等一下，
      如果店中有产品了再通知消费者来取走产品。

5.wait()和sleep()的区别
相同点：一旦执行，当前线程都会进入阻塞的状态
不同点：
    》声明的位置：wait()声明在Object类中，为非静态方法。sleep()声明在Thread类中，为静态方法。
    》使用的场景不同：wait()只能在同步代码块或同步方法中使用。sleep()可以在任何场景中使用。
    》使用在同步代码块或同步方法中：wait()一旦执行就会释放同步监视器。sleep()不会释放同步监视器
    》结束阻塞的方式：wait()到达指定时间自动结束阻塞(有时长的wait)或通过被notify唤醒结束阻塞(不管有没有时长)。sleep()到达指定时间自动结束阻塞。